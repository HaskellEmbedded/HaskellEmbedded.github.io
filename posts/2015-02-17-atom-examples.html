<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>Haskell Embedded Blog - Examples for the Atom library (DRAFT)</title>
        <link href="../css/bootstrap.css" rel="stylesheet" />
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <!-- syntax.css is Pandoc's syntax.css file, copied from:
             https://github.com/jaspervdj/hakyll/blob/master/web/css/syntax.css
          -->
        <link rel="stylesheet" type="text/css" href="../css/syntax.css" />

        <link rel="apple-touch-icon" sizes="57x57" href="../apple-touch-icon-57x57.png">
        <link rel="apple-touch-icon" sizes="60x60" href="../apple-touch-icon-60x60.png">
        <link rel="apple-touch-icon" sizes="72x72" href="../apple-touch-icon-72x72.png">
        <link rel="apple-touch-icon" sizes="76x76" href="../apple-touch-icon-76x76.png">
        <link rel="apple-touch-icon" sizes="114x114" href="../apple-touch-icon-114x114.png">
        <link rel="apple-touch-icon" sizes="120x120" href="../apple-touch-icon-120x120.png">
        <link rel="apple-touch-icon" sizes="144x144" href="../apple-touch-icon-144x144.png">
        <link rel="apple-touch-icon" sizes="152x152" href="../apple-touch-icon-152x152.png">
        <link rel="apple-touch-icon" sizes="180x180" href="../apple-touch-icon-180x180.png">
        <link rel="icon" type="image/png" href="../favicon-32x32.png" sizes="32x32">
        <link rel="icon" type="image/png" href="../android-chrome-192x192.png" sizes="192x192">
        <link rel="icon" type="image/png" href="../favicon-96x96.png" sizes="96x96">
        <link rel="icon" type="image/png" href="../favicon-16x16.png" sizes="16x16">
        <link rel="manifest" href="../manifest.json">
        <meta name="msapplication-TileColor" content="#da532c">
        <meta name="msapplication-TileImage" content="/mstile-144x144.png">
        <meta name="theme-color" content="#ffffff">
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../">Haskell Embedded Blog</a>
            </div>
            <div id="navigation">
                <a href="../">Home</a>
                <a href="../about.html">About</a>
                <a href="../contact.html">Contact</a>
                <a href="../archive.html">Archive</a>
            </div>
        </div>

        <div id="content">
            <h1>Examples for the Atom library (DRAFT)</h1>

            <div class="info">
    Posted on February 17, 2015
    
        by Chris Hodapp
    
</div>

<p>In the <a href="./2015-02-06-how-i-got-here.html">last post</a> I talked briefly about <a href="http://hackage.haskell.org/package/atom" title="atom: A DSL for embedded hard realtime applications. (hackage)">Atom</a>, a Haskell EDSL from <a href="http://tomahawkins.org/">Tom Hawkins</a> for hard realtime embedded software. I hope to go into a little more detail here.</p>
<h1 id="background">Background</h1>
<p>As that post mentioned, I was running into problems handling concurrency in software for my embedded target (a <a href="https://www.nordicsemi.com/eng/Products/Bluetooth-Smart-Bluetooth-low-energy/nRF51822">Nordic nRF51822</a>). My embedded software had operations throughout that required some fairly specific timing, for instance:</p>
<ol style="list-style-type: decimal">
<li>Activate some circuit.</li>
<li>Wait <em>at least</em> 300 milliseconds for that circuit to settle.</li>
<li>Trigger the circuit to send a pulse.</li>
<li>Wait <em>exactly</em> 145 microseconds, and set circuit to receive mode.</li>
<li>Wait <em>at least</em> a millisecond.</li>
<li>Send a command over SPI to trigger a reading.</li>
<li>Wait <em>at most</em> 1 millisecond for an acknowledgement.</li>
<li>Repeat 6 and 7 to read the contents of 3 or 4 other registers.</li>
</ol>
<p>This was simple enough, except that the processor had to share a dozen similar processes simultaneously. The delay function could delay precisely, but by busy-looping, blocking other execution and wasting power, a precious resource here. Timer callbacks and state machines could share execution delay for longer periods, but at the cost of extra complexity.</p>
<p>I looked at a variety of solutions which implemented schedulers that ran directly on the target, but nearly all of them appeared to either interfere with Nordic’s firmware or require too extensive of an implementation. The one that I finally could port, <a href="http://www.cocoos.net/intro.html">cocoOS</a>, had the rather show-stopping issue that its primitives were simply using more resources than I had available.</p>
<h1 id="introduction-to-atom">Introduction to Atom</h1>
<p>At this point I started looking at Atom. Its documentation is a bit lacking, and with no updates on its Hackage page in 2 years, I expect no change in that - which is a shame, because this is substantial industry work that was open-sourced. I’m slowly understanding it from what I can find, mainly:</p>
<ul>
<li>Hackage documentation:
<ul>
<li><a href="http://hackage.haskell.org/package/atom-1.0.12/docs/Language-Atom-Code.html">Language.Atom.Code</a></li>
<li><a href="http://hackage.haskell.org/package/atom-1.0.12/docs/Language-Atom-Common.html">Language.Atom.Common</a></li>
<li><a href="http://hackage.haskell.org/package/atom-1.0.12/docs/src/Language-Atom-Example.html">Language.Atom.Example</a></li>
<li><a href="http://hackage.haskell.org/package/atom-1.0.12/docs/Language-Atom-Expressions.html">Language.Atom.Expressions</a></li>
<li><a href="http://hackage.haskell.org/package/atom-1.0.12/docs/Language-Atom-Language.html">Language.Atom.Language</a></li>
</ul></li>
<li>some slides from creator Tom Hawkins in 2008, <a href="http://cufp.galois.com/2008/slides/HawkinsTom.pdf" title="Controlling Hybrid Vehicles with Haskell. Hawkins, T. (2008).">Controlling Hybrid Vehicles with Haskell</a>. Some names in the example code have since changed, such as <code>atom</code> replacing <code>system</code>.</li>
<li>a more formal example from Lee Pike, <a href="https://leepike.wordpress.com/2009/05/05/an-atomic-fibonacci-server-exploring-the-atom-haskell-dsl/" title="An Atomic Fibonacci Server: Exploring the Atom (Haskell) DSL. Pike. L. (2009).">An Atomic Fibonacci Server: Exploring the Atom (Haskell) DSL</a>. His links to code examples appear to be down, but the Wayback Machine has old copies.</li>
<li>a 2009 blog post from Don Stewart, <a href="https://archhaskell.wordpress.com/2009/08/01/atom-a-domain-specific-language-for-hard-realtime-applications" title="Atom : a domain specific language for hard realtime applications. Stewart, D. (2009).">Atom : a domain specific language for hard realtime applications</a></li>
<li>two now-offline blog posts from John Van Enk at blog.sw17ch.com, <a href="https://web.archive.org/web/20110812162216/http://blog.sw17ch.com/wordpress/?p=84" title="Atom &amp; Arduino : Some Hacking (pt. 1). Van Enk, J. (2009).">Atom &amp; Arduino : Some Hacking (pt. 1)</a> and <a href="https://web.archive.org/web/20110812162107/http://blog.sw17ch.com/wordpress/?p=111" title="Atom &amp; Arduino : First Program (pt. 2). Van Enk, J. (2009).">Atom &amp; Arduino : First Program (pt. 2)</a></li>
<li><a href="https://github.com/eightyeight/atom-msp430">atom-msp430</a>, 3rd-party code for interfacing with MSP430 microcontrollers.</li>
</ul>
<p>Atom’s approach is a bit different than anything I’d mentioned in the prior section. As Hawkins’ slides mention at page 12, Atom’s compiler handles scheduling and synchronization, avoiding the need for locks, semaphores, or any kind of scheduling at run-time. As a Haskell EDSL, it also moves the abstraction up into Haskell rather than trying to make abstractions accessible from C, and that is not a trivial benefit.</p>
<p>Lee Pike in his link refers to Atom as a <a href="https://en.wikipedia.org/wiki/Synchronous_programming_language">synchronous language</a>: one specifies rules that fire on clock ticks, and state changes are atomic. This is good to bear in mind when understanding Atom definitions.</p>
<h1 id="example">Example</h1>
<p>This post’s <a href="./2015-02-17-atom-examples.lhs">source code</a> is a Literate Haskell file, so you may run it directly. Only <code>cabal install atom</code> should be needed. The source code gives an example Atom specification which does two things:</p>
<ol style="list-style-type: decimal">
<li>Keeps track of a global clock in seconds.</li>
<li>Monitors a sensor periodically via some external function calls, and performs some action whenever the sensor’s value exceeds a threshold.</li>
</ol>
<p>The rest of the source code is for configuration and interfacing with the Atom compiler.</p>
<h2 id="standard-boilerplate">Standard Boilerplate</h2>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Language.Atom</span>
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Language.Atom.Unit</span>
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">GHC.Word</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt; main ::</span> <span class="dt">IO</span> ()
<span class="ot">&gt;</span> main <span class="fu">=</span> <span class="kw">do</span>
<span class="ot">&gt;</span>    (sched, _, _, _, _) <span class="ot">&lt;-</span> compile <span class="st">&quot;atom_example&quot;</span> atomCfg example
<span class="ot">&gt;</span>    putStrLn <span class="fu">$</span> reportSchedule sched</code></pre>
<p><code>main</code> just runs the Atom compiler via <a href="http://hackage.haskell.org/package/atom-1.0.12/docs/Language-Atom-Compile.html#v:compile">Language.Atom.Compile.compile</a>. The function below will produce C source code in <code>atom_example.c</code> and <code>atom_example.h</code>, and it will call <a href="http://hackage.haskell.org/package/atom-1.0.12/docs/Language-Atom-Compile.html#v:reportSchedule">reportSchedule</a> to output some (maybe) meaningful information.</p>
<p><code>example</code> is the important part and it’s defined a few sections below.</p>
<h2 id="configuration">Configuration</h2>
<p><code>atomCfg</code> gives some code generation configuration via <a href="http://hackage.haskell.org/package/atom-1.0.12/docs/Language-Atom-Code.html#t:Config">Language.Atom.Code.Config</a>. Most items here have sane defaults and are out of scope for this example; we turn off rule coverage checking with <code>cRuleCoverage</code>. I define two optional ones that are quite important in the generated code:</p>
<ul>
<li><code>cFuncName</code> is the name of the top-level C function that must be called at regular intervals, such as by a timer interrupt.</li>
<li><code>cStateName</code> is the name of a C struct that includes all global state.</li>
</ul>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; atomCfg ::</span> <span class="dt">Config</span>
<span class="ot">&gt;</span> atomCfg <span class="fu">=</span> defaults { cFuncName <span class="fu">=</span> <span class="st">&quot;atom_tick&quot;</span>
<span class="ot">&gt;</span>                    , cStateName <span class="fu">=</span> <span class="st">&quot;state_example&quot;</span>
<span class="ot">&gt;</span>                    , cCode <span class="fu">=</span> prePostCode
<span class="ot">&gt;</span>                    , hCode <span class="fu">=</span> prePostHeader
<span class="ot">&gt;</span>                    , cRuleCoverage <span class="fu">=</span> <span class="dt">False</span>
<span class="ot">&gt;</span>                    }</code></pre>
<h2 id="pre-post-code">Pre &amp; Post Code</h2>
<p>The Hackage documentation defines <code>cCode</code> and <code>hCode</code> better, including the arguments I’m ignoring. For now, all I have here is some comments that go above and below in the generated code and generated header, respectively:</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; prePostCode ::</span> [<span class="dt">Name</span>] <span class="ot">-&gt;</span> [<span class="dt">Name</span>] <span class="ot">-&gt;</span> [(<span class="dt">Name</span>, <span class="dt">Type</span>)] <span class="ot">-&gt;</span> (<span class="dt">String</span>, <span class="dt">String</span>)
<span class="ot">&gt;</span> prePostCode _ _ _ <span class="fu">=</span>
<span class="ot">&gt;</span>   ( unlines [ <span class="st">&quot;// ---- This source is automatically generated by Atom ----&quot;</span>
<span class="ot">&gt;</span>             ]
<span class="ot">&gt;</span>   , unlines [ <span class="st">&quot;// ---- End automatically-generated source ----&quot;</span>
<span class="ot">&gt;</span>             ])
<span class="ot">&gt;</span> 
<span class="ot">&gt; prePostHeader ::</span> [<span class="dt">Name</span>] <span class="ot">-&gt;</span> [<span class="dt">Name</span>] <span class="ot">-&gt;</span> [(<span class="dt">Name</span>, <span class="dt">Type</span>)] <span class="ot">-&gt;</span> (<span class="dt">String</span>, <span class="dt">String</span>)
<span class="ot">&gt;</span> prePostHeader _ _ _ <span class="fu">=</span>
<span class="ot">&gt;</span>   ( unlines [ <span class="st">&quot;// ---- This header is automatically generated by Atom ----&quot;</span>
<span class="ot">&gt;</span>             ]
<span class="ot">&gt;</span>   , unlines [ <span class="st">&quot;// ---- End automatically-generated header ----&quot;</span>
<span class="ot">&gt;</span>             ])</code></pre>
<h2 id="top-level-example-rule">Top-level (<code>example</code>) Rule</h2>
<p>Finally, I may describe the actual code that does something. Here is <code>example</code>, my top-level definition that I pass to the Atom compiler. This is the first appearance of the slightly-redundantly-named <a href="http://hackage.haskell.org/package/atom-1.0.12/docs/Language-Atom-Language.html">Language.Atom.Language.Atom</a> monad, which “captures variable and transition rule declarations.”</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; example ::</span> <span class="dt">Atom</span> ()
<span class="ot">&gt;</span> example <span class="fu">=</span> <span class="kw">do</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span>   clock <span class="ot">&lt;-</span> tickSecond
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span>   checkSensor <span class="dv">16384</span> <span class="fu">$</span> <span class="kw">do</span>
<span class="ot">&gt;</span>     call <span class="st">&quot;on_sensor_over_threshold&quot;</span>
<span class="ot">&gt;</span>     printStrLn <span class="st">&quot;Sensor value over threshold!&quot;</span></code></pre>
<p>I define both <code>tickSecond</code> and <code>checkSensor</code> below. The arguments to <code>checkSensor</code> are, respectively, a sensor threshold, and an action to trigger if the sensor exceeds that threshold - more on this later.</p>
<h2 id="ticksecond-rule"><code>tickSecond</code> Rule</h2>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; tickSecond ::</span> <span class="dt">Atom</span> (<span class="dt">V</span> <span class="dt">Word64</span>)
<span class="ot">&gt;</span> tickSecond <span class="fu">=</span> <span class="kw">do</span>
<span class="ot">&gt;</span>   clock <span class="ot">&lt;-</span> word64 <span class="st">&quot;clock_sec&quot;</span> <span class="dv">0</span>
<span class="ot">&gt;</span>   period <span class="dv">1000</span> <span class="fu">$</span> exactPhase <span class="dv">0</span> <span class="fu">$</span> atom <span class="st">&quot;second&quot;</span> <span class="fu">$</span> incr clock
<span class="ot">&gt;</span>   return clock</code></pre>
<p>Note a few new things:</p>
<ul>
<li>I define <code>clock</code> via <a href="http://hackage.haskell.org/package/atom-1.0.12/docs/Language-Atom-Language.html#v:word64">word64</a>, which introduces a local variable, an unsigned 64-bit integer. “clock_sec” is a C name - more specifically, the field name inside the struct above whose name I set with <code>cStateName</code>. 0 is an initial value.</li>
<li>I’ve defined a sub-rule with <a href="http://hackage.haskell.org/package/atom-1.0.12/docs/Language-Atom-Language.html#v:period">period</a> which executes at 1 / 1000 of the base rate of the system. I’ve also used <a href="http://hackage.haskell.org/package/atom-1.0.12/docs/Language-Atom-Language.html#v:exactPhase">exactPhase</a> to dictate that it runs first in that period (i.e. at <a href="http://hackage.haskell.org/package/atom-1.0.12/docs/Language-Atom-Language.html#v:phase">phase</a> 0).</li>
<li>I return <code>clock</code> in the monad. Its <code>V Word64</code> type wraps a standard Haskell <code>Data.Word.Word64</code>.</li>
</ul>
<p>I mentioned <em>base rate of the system.</em> That base rate is the rate at which I call <code>atom_tick</code> (the function set earlier with <code>cFuncName</code>). I intend to write the C code to call it at intervals of 1 millisecond. Thus, the sub-rule above executes at 1 / 1000 of this - once every second.</p>
<p>I give the sub-rule a unique name (“second”), and the sub-rule is responsible for incrementing <code>clock</code> via <a href="http://hackage.haskell.org/package/atom-1.0.12/docs/Language-Atom-Language.html#v:incr">incr</a>, once per second.</p>
<h2 id="checksensor-rule"><code>checkSensor</code> Rule</h2>
<p>Next, suppose I have a sensor I want to monitor, but getting a sensor measurement is a process like this:</p>
<ol style="list-style-type: decimal">
<li>Power it on via a C call <code>sensor_on</code>.</li>
<li>Wait at least 10 milliseconds for it to settle.</li>
<li>Trigger a measurement via a C call <code>sensor_trigger</code>.</li>
<li>Wait for some external variable <code>g_sensor_ready</code> to indicate true.</li>
<li>Receive our result in another external variable, <code>g_sensor_value</code>.</li>
<li>Power the sensor off via <code>sensor_off</code>.</li>
</ol>
<p>Suppose, also, we want a threshold value and an action to take if the sensor exceeds that threshold.</p>
<p>I attempt to do this below:</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; checkSensor ::</span> <span class="dt">Word16</span> <span class="ot">-&gt;</span> <span class="dt">Atom</span> () <span class="ot">-&gt;</span> <span class="dt">Atom</span> ()
<span class="ot">&gt;</span> checkSensor threshold action <span class="fu">=</span> atom <span class="st">&quot;check_sensor&quot;</span> <span class="fu">$</span> <span class="kw">do</span>
<span class="ot">&gt;</span>   ready <span class="ot">&lt;-</span> return <span class="fu">$</span> bool' <span class="st">&quot;g_sensor_ready&quot;</span>
<span class="ot">&gt;</span>   sensor_value <span class="ot">&lt;-</span> return <span class="fu">$</span> word16' <span class="st">&quot;g_sensor_value&quot;</span>
<span class="ot">&gt;</span>   warmup <span class="ot">&lt;-</span> timer <span class="st">&quot;warmup&quot;</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span>   period <span class="dv">2000</span> <span class="fu">$</span> phase <span class="dv">500</span> <span class="fu">$</span> atom <span class="st">&quot;powerOn&quot;</span> <span class="fu">$</span> <span class="kw">do</span>
<span class="ot">&gt;</span>     call <span class="st">&quot;sensor_on&quot;</span>
<span class="ot">&gt;</span>     startTimer warmup <span class="fu">$</span> <span class="dt">Const</span> <span class="dv">10</span>
<span class="ot">&gt;</span>   
<span class="ot">&gt;</span>   atom <span class="st">&quot;trigger&quot;</span> <span class="fu">$</span> <span class="kw">do</span>
<span class="ot">&gt;</span>     cond <span class="fu">$</span> timerDone warmup
<span class="ot">&gt;</span>     ready <span class="fu">&lt;==</span> false
<span class="ot">&gt;</span>     call <span class="st">&quot;sensor_trigger&quot;</span>
<span class="ot">&gt;</span>     
<span class="ot">&gt;</span>   atom <span class="st">&quot;checkSensorValue&quot;</span> <span class="fu">$</span> <span class="kw">do</span>
<span class="ot">&gt;</span>     cond <span class="fu">$</span> value ready
<span class="ot">&gt;</span>     ready <span class="fu">&lt;==</span> false
<span class="ot">&gt;</span>     call <span class="st">&quot;sensor_off&quot;</span>
<span class="ot">&gt;</span>     cond <span class="fu">$</span> value sensor_value <span class="fu">&gt;.</span> <span class="dt">Const</span> threshold
<span class="ot">&gt;</span>     action</code></pre>
<p>While <code>atom &quot;check_sensor&quot;</code> may not (as I understand it) be strictly necessary here, that call to <a href="http://hackage.haskell.org/package/atom-1.0.12/docs/Language-Atom-Language.html#v:atom">atom</a> defines this whole thing as a sub-rule, and this hierarchy will emerge in the organization and identifiers in the generated code.</p>
<p>I use a few new constructs here:</p>
<ul>
<li><em>External variables:</em> I introduce <code>ready</code> using <a href="hackage.haskell.org/package/atom-1.0.12/docs/Language-Atom-Language.html#v:bool-39-">bool’</a>, tying it to an external C variable <code>g_sensor_ready</code> (and likewise <code>sensor_value</code> to <code>g_sensor_value</code> using <a href="hackage.haskell.org/package/atom-1.0.12/docs/Language-Atom-Language.html#v:word16-39-">word16’</a>).<br /></li>
<li><em>Timers:</em> <code>warmup</code> is a <a href="http://hackage.haskell.org/package/atom-1.0.12/docs/Language-Atom-Common.html#t:Timer">Timer</a> which I use to count down 10 ticks (10 milliseconds) from the time of powering on the sensor (see <a href="http://hackage.haskell.org/package/atom-1.0.12/docs/Language-Atom-Common.html#v:startTimer">startTimer</a> in the <code>powerOn</code> rule).</li>
<li><em>Conditionals:</em> The rule <code>trigger</code> makes use of <a href="http://hackage.haskell.org/package/atom-1.0.12/docs/Language-Atom-Language.html#v:cond">cond</a> to execute only when that timer has finished. The rule <code>checkSensorValue</code> likewise uses it to execute only when the measurement is ready, and to execute <code>action</code> only when the value exceeds the threshold.</li>
</ul>
<p>Note also that the rule <code>powerOn</code> has period 2000 and phase 500: It runs every 2 seconds, offset by 1/2 second. The other two rules implicitly have period 1 - they run at every clock tick.</p>
<h1 id="big-gaping-holes-in-this-example">Big Gaping Holes in This Example</h1>
<p>Things I still have not touched:</p>
<ol style="list-style-type: decimal">
<li>Phases (in any useful sense)</li>
<li>Probes</li>
<li>Assertions</li>
<li>Coverage checking</li>
<li>What the Atom compiler outputs</li>
<li>What generated code looks like</li>
<li>Periods overriding later periods</li>
<li>The practical notion that you can apply periods and phases to entire sub-rules if you like</li>
</ol>

        </div>
        <div id="footer">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
        <script src="../js/bootstrap.js"></script>
    </body>
</html>
