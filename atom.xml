<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Haskell Embedded: Functional Programming and Embedded Systems</title>
    <link href="http://haskellembedded.github.io//atom.xml" rel="self" />
    <link href="http://haskellembedded.github.io/" />
    <id>http://haskellembedded.github.io//atom.xml</id>
    <author>
        <name></name>
        <email></email>
    </author>
    <updated>2015-10-09T00:00:00Z</updated>
    <entry>
    <title>Embedding Haskell: Compilers, and compiling compilers</title>
    <link href="http://haskellembedded.github.io//posts/2015-10-09-compiler-compilers.html" />
    <id>http://haskellembedded.github.io//posts/2015-10-09-compiler-compilers.html</id>
    <published>2015-10-09T00:00:00Z</published>
    <updated>2015-10-09T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on October  9, 2015
    
        by Chris Hodapp
    
</div>
<div class="info">
    
    Tags: <a href="/tags/haskell.html">haskell</a>, <a href="/tags/ramblings.html">ramblings</a>
    
</div>

<p>My <a href="../posts/2015-06-09-atom-cincyfp-slides.html">last post</a> mentioned that some things need some better explanation, because I’m always trying to re-explain and clarify.</p>
<p>This blog is devoted to the use of Haskell with embedded systems. What does that even mean? We see a couple broad categories (which the slides on the last page, as well as our <a href="../pages/links.html">Links</a> page, mirror):</p>
<ol style="list-style-type: decimal">
<li><em>Full Compilation:</em> Compiling Haskell code to an embedded target.</li>
<li><em>Limited Compilation:</em> Compiling some limited subset of Haskell code to an embedded target.</li>
<li><em>Hosted EDSL &amp; Compiler:</em> Hosting, in Haskell, an EDSL and a compiler to an embedded target.</li>
</ol>
<p>As far as I know, I made these categories up. If anyone happens to know a more established classification, better names, or an example of who wrote about it first, please tell me.</p>
<p>This might look like a lopsided, arbitrary grouping; it sort of is. The commonality is that in all cases one uses Haskell to express something (a program, a circuit, specifications, call it what you will) for an embedded target. More on that follows.</p>
<p>I exclude things like Cryptol and Idris from this because - while implemented in Haskell and usable for embedded platforms - they are different languages unto themselves. I might arbitrarily drop that distinction in the future if I feel like it…</p>
<h1 id="full-compilation">Full Compilation</h1>
<p>This is what normally comes to mind when people hear about using Haskell with embedded systems - compiling the Haskell code to run directly on an embedded target, bringing along the normal runtime with it (plus whatever required bootstrapping and support). The <a href="../pages/links.html#compiling-to-embedded-targets">Compiling to Embedded Targets</a> section of the Links page is concerned particularly with this.</p>
<p>However, this actually appears to be pretty rare. The nature of the Haskell language brings some formidable challenges. Particularly, one must make the Haskell runtime fit on the target and make the garbage collection and lazy evaluation behave in predictable and sane ways.</p>
<p>Ajhc (<a href="https://github.com/ajhc/ajhc" class="uri">https://github.com/ajhc/ajhc</a>), a JHC-derived compiler from Kiwamu Okabe of METASEPI, is the only example of this I found - it could compile and execute on ARM Cortex-M3/M4. Kiwamu has written a lot on his experiences with making Haskell run in this footprint. His subsequent switch to the ATS language may be a hint.</p>
<p><a href="https://github.com/galoisinc/halvm">HaLVM</a> from Galois might arguably fit in this category.</p>
<h1 id="limited-compilation">Limited Compilation</h1>
<p>This uses an existing compiler for certain stages (such as the parsing and type-checking), but a custom back-end to actually produce code, often with a lot of static analysis. This may adapt or disallow certain constructs (for instance, floating-point, recursive functions, recursive datatypes: <a href="http://hackage.haskell.org/package/clash-prelude-0.10/docs/CLaSH-Tutorial.html#unsupported">CλaSH Unsupported Haskell features</a>).</p>
<p>GHC accomodates this by allowing developers to invoke GHC functionality, from Haskell, <a href="https://wiki.haskell.org/GHC/As_a_library">as a library</a>.</p>
<p>The <a href="../pages/links.html#compiling-for-fpgaasic">Compiling for FPGA/ASIC</a> section of the Links page has a few examples of this.</p>
<h1 id="hosted-edsl-compiler">Hosted EDSL &amp; Compiler</h1>
<p>The <a href="../pages/links.html#code-generation-edsls">Code Generation EDSLs</a> and <a href="../pages/links.html#circuit-design-edsls">Circuit Design EDSLs</a> sections of the Links page cover the copious examples of this. Atom, the topic of a few of my <a href="../posts/2015-02-17-atom-examples.lhs">prior posts</a>, is in this category.</p>
<p>This category is the one I am most often having to explain. It typically uses an EDSL (embedded domain-specific language) inside of Haskell to direct the process of code generation to a lower-level representation. This is otherwise called: <em>compiling</em>.</p>
<p>To emphasize: The code that runs on the target is <em>entirely decoupled from the Haskell runtime</em>. The Haskell compiler here isn’t compiling anything for the target - it’s compiling another compiler and the input to that compiler. That input happens to be specifications of what <em>will</em> run on the target.</p>
<p>This is a limitation of one sort:</p>
<ul>
<li>Basically all notions of ‘runtime’ on the embedded target must be handled separately. (Ivory works with this still, for instance with the <a href="https://hackage.haskell.org/package/base/docs/Prelude.html#t:Num">Num</a> typeclass, in some surprising ways. More on that will follow in a future post!)</li>
<li>This adds the confusion and complication of another stage (possibly multiple stages) to the process of bringing code/specifications to the embedded target. This is why I use <a href="http://shakebuild.com/">Shake</a>.</li>
</ul>
<p>It’s also a benefit of another sort:</p>
<ul>
<li>Any Haskell environment compatible with the libraries in question should produce the same results (as far as the embedded target cares). Its runtime does not matter, nor whether the environment has any knowledge of the architecture of the embedded target.</li>
<li>That stage separation also adds a nice opportunity for static analysis and optimization. For instance, Copilot makes use of this to add an interpreter/simulator, SBV uses it to prove or disprove given properties about the code, and Atom uses it to verify some timing constraints.</li>
</ul>
<p>I said in the <a href="../posts/2015-06-09-atom-cincyfp-slides.html">last post</a> that in this category Haskell takes on the role of a metaprogramming or template language. While this may be true, I sort of ignored that it’s less relevant, because it’s the same in all the other categories.</p>
<h1 id="commonality">Commonality</h1>
<p>Lumping together these categories might seem like a stretch, especially considering that the last category involves extra stages and a shift in how one thinks about the software.</p>
<p>Ponder the following, though:</p>
<ul>
<li>A “normal” Haskell program interacts through what is sequenced in the famous <a href="https://hackage.haskell.org/package/base/docs/System-IO.html">IO</a> monad (particularly, the value called <code>main</code>).</li>
<li>An Atom specification interacts through what is sequenced in the <a href="https://hackage.haskell.org/package/atom-1.0.13/docs/Language-Atom.html#t:Atom">Atom</a> monad (particularly, whichever values one passes to the <a href="https://hackage.haskell.org/package/atom-1.0.13/docs/Language-Atom.html#g:2">Atom compiler</a>).</li>
<li>An Ivory program interacts through what is sequenced in the <a href="https://hackage.haskell.org/package/ivory-0.1.0.0/docs/Ivory-Language.html#t:Ivory">Ivory eff</a> and <a href="https://hackage.haskell.org/package/ivory-0.1.0.0/docs/Ivory-Language.html#t:Module">Module</a> monads (particularly, whichever values one passes to the <a href="https://hackage.haskell.org/package/ivory-backend-c-0.1.0.1/docs/Ivory-Compile-C.html">Ivory compiler</a>).</li>
<li>A <a href="http://www.clash-lang.org/">CλaSH</a> description interacts through the <a href="https://hackage.haskell.org/package/clash-prelude-0.10/docs/CLaSH-Signal.html#t:Signal">Signal</a> applicative (particularly, the value called <a href="https://hackage.haskell.org/package/clash-prelude-0.10/docs/CLaSH-Annotations-TopEntity.html">topEntity</a>).</li>
</ul>
<p>Is a trend clear? (No, it’s not monads. <a href="https://hackage.haskell.org/package/clash-prelude-0.10/docs/CLaSH-Signal.html#t:Signal">Signal</a> is only applicative, and I suspect Lava behaves similarly.)</p>
<p>That list spans our three categories. In each of them, one builds up a program (in a very broad sense) simply by building up a value in Haskell. Beyond that, the only real differences are,</p>
<ul>
<li>the type of that value,</li>
<li>what system handles it (the Haskell compiler and runtime, some other compiler and maybe runtime, or a combination thereof),</li>
<li>and the eventual output (native binary, LLVM bitcode, C code, VHDL code, assembly language, input to a model checker, etc.).</li>
</ul>
<p>Ignoring the vague nature of the term, “declarative,” this relates pretty directly to the <em>declarative</em> nature of Haskell programs.</p>
<p>Seen from this perspective, one is still <em>compiling Haskell</em> to run on some embedded target. The compilation just might continue outside of the system’s Haskell compiler, and the running might not involve its runtime.</p>
]]></summary>
</entry>
<entry>
    <title>Presentation at CincyFP</title>
    <link href="http://haskellembedded.github.io//posts/2015-06-09-atom-cincyfp-slides.html" />
    <id>http://haskellembedded.github.io//posts/2015-06-09-atom-cincyfp-slides.html</id>
    <published>2015-06-09T00:00:00Z</published>
    <updated>2015-06-09T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on June  9, 2015
    
        by Chris Hodapp
    
</div>
<div class="info">
    
    Tags: <a href="/tags/haskell.html">haskell</a>, <a href="/tags/atom.html">atom</a>
    
</div>

<p><em>Later note: This post is back-dated because while I’d put the slides in the repository already, I had not actually linked to them or said anything about them.</em></p>
<p>The fine people at <a href="https://cincyfp.wordpress.com/">CincyFP</a>, the local (to me) functional programming group, requested that I give a presentation on some of the embedded Haskell stuff I was doing, and I did this at the <a href="https://cincyfp.wordpress.com/2015/06/04/june-meeting-4/">June meeting</a> this year.</p>
<p>Slides from the presentation are up <a href="../slides/20150609_CincyFP/Slides.html">here</a> (and <a href="../slides/20150609_CincyFP/Slides.md">Markdown source</a>; or look <a href="https://github.com/HaskellEmbedded/HaskellEmbedded.github.io/tree/master/slides/20150609_CincyFP">in the repo</a>). CincyFP seems to have mostly Clojure aficionados, so in terms of Haskell-heavy details I kept this presentation as a “part 1” to some possible future presentations. Actually, not even that, since the title was “EDSLs &amp; Metaprogramming” and I only scratched the surface of that.</p>
<p>I start walking through an Atom example at slide 9. While I live-coded this at the presentation, I have no video or audio. However, I put my example code online <a href="../slides/20150609_CincyFP/Example.hs">here</a> (and <a href="../slides/20150609_CincyFP/StringEmbed.hs">StringEmbed.hs</a>).</p>
<p>The slides are fairly terse, and I intend to explain bits of them in the next few posts. Particularly, around slide 2, I try to explain a few different broad ways Haskell might be used on embedded systems, and this refers to similar categories as on the <a href="../pages/links.html">Links</a> page. I find myself having to explain these distinctions quite often, so I am going to try to explain this better in posts to come.</p>
<p>Slide 6 is a little bit misleading. The next post tries to patch this up a bit.</p>
]]></summary>
</entry>
<entry>
    <title>How I Got Here (i.e. to using Haskell for embedded code)</title>
    <link href="http://haskellembedded.github.io//posts/2015-02-06-how-i-got-here.html" />
    <id>http://haskellembedded.github.io//posts/2015-02-06-how-i-got-here.html</id>
    <published>2015-02-06T00:00:00Z</published>
    <updated>2015-02-06T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on February  6, 2015
    
        by Chris Hodapp
    
</div>
<div class="info">
    
    Tags: <a href="/tags/haskell.html">haskell</a>, <a href="/tags/atom.html">atom</a>, <a href="/tags/ivory.html">ivory</a>, <a href="/tags/copilot.html">copilot</a>, <a href="/tags/idris.html">idris</a>, <a href="/tags/sbv.html">sbv</a>, <a href="/tags/python.html">python</a>
    
</div>

<p>One work project since near the begining of 2014 has been the design of an embedded system for which power usage and stability are two primary concerns. It’s not controlling an airplane or a nuclear plant - malfunctions will not be catastrophic - but stability still matters.</p>
<p>My boss had decided that for various reasons too numerous and extensive to list here, we needed to have support for Bluetooth Low Energy. Our system at the time ran on the venerable TI MSP430 and I started looking at ways to support BLE from this. All of TI’s BLE offerings at the time ran on the 8051 and appeared to require proprietary toolchains. After surveying what else was available, we had eventually decided on the <a href="https://www.nordicsemi.com/eng/Products/Bluetooth-Smart-Bluetooth-low-energy/nRF51822">Nordic nRF51822</a>, a microcontroller based on an ARM Cortex-M0, supported by standard GCC, and providing all the necessary peripherals for BLE - and simply eliminated the MSP430 altogether.</p>
<p>It quickly evolved to a distributed system - some parts were sensors or actuators that were BLE peripherals, another part ran constantly as a BLE central, another part ended up as a more powerful, Internet-connected Linux machine that ran only sparingly.</p>
<p>A few patterns emerged:</p>
<ul>
<li>All parts needed to be speaking the same protocol, which necessitated keeping various structures and constants in sync at the software each part ran.</li>
<li>The nRF51822 board acting as the BLE central was responsible for juggling a lot of concurrent operations, because nearly all API calls were async.</li>
<li>The nRF51822 boards ran different software, but still shared various bits of code and constants.</li>
</ul>
<p>The two languages here were C for the nRF51822, and Python for the Linux machine. I tried to build abstractions that could sensibly represent these patterns, but were sufficiently lightweight in C. One was in Python to keep data types in sync; for Linux, it handled it at runtime in Python, and for the microcontroller, it generated C code with the requisite <code>memcpy</code> calls and proper offsets and lengths. The C code also had various FSMs (some explicit, some not) for managing the concurrent operations. At later examination they were nearly all ad-hoc coroutines that were ‘hiding’ a very simple concurrent description in their details.</p>
<p>Seeing that I had ad-hoc coroutines hidden everywhere in my code, I tried to integrate in some lightweight RTOSes that provided some form of cooperative thread or coroutine. I looked at <a href="http://atomthreads.com/">Atomthreads</a>, <a href="http://www.riot-os.org/">RIOT OS</a>, <a href="http://www.contiki-os.org/">Contiki</a>, <a href="http://www.freertos.org/">FreeRTOS</a>, and <a href="http://www.chibios.org/dokuwiki/doku.php">ChibiOS/RT</a>, but the issue that stopped me in all cases was that they appeared they would interfere with Nordic’s firmware, which I required for the Bluetooth Low Energy functionality. Finally, I discovered <a href="http://www.cocoos.net/intro.html">cocoOS</a> which provided just the cooperative threads and basic messaging primitives, and due to its simplicity required only minimal implementation and nothing very low-level. I quickly ported it and it was working seemingly wonderfully.</p>
<p>I had recently read Joe Armstrong’s famous <a href="http://www.erlang.org/download/armstrong_thesis_2003.pdf">thesis on Erlang</a>, and found it very cogent and pragmatic, but still accessible. He defines on page 19 <em>Concurrency Oriented Programming</em>. I had a thought that perhaps cocoOS gave me the primitives I needed to let me apply the methodology that Armstrong described, and express the system as a design around concurrent processes. With clean system design in hand and hopeful visions of elegance in my head, I set about working on this - until reaching an abrupt ending when I ran out of memory with around 2 cooperative tasks and almost nothing else compiled in.</p>
<p>Around the same point, I had also extended my Python code generation to generate code for some more complex protocols and refactored it to make use of a very handy library, <a href="https://www.python.org/about/success/cog/">Cog</a>.</p>
<p>At some point I saw that these all were sides of the same ugly dilemma (trilemma?):</p>
<ul>
<li>I could write larger amounts of code that would ‘hide’ the simpler representations inside.</li>
<li>I could attempt to streamline the above with code generation via macros.</li>
<li>I could build or use runtime abstractions that helped me approximate those simpler representations, but incurred too much overhead.</li>
</ul>
<p><code>#define</code> and <code>#include</code> existed, but they addressed only the smallest of cases, and I felt like C++ was no cure either. Cog helped streamline the code generation, but my code generation still felt like primitive macros. My view of code generation in general was grim too, from seeing its use at other jobs. In particular:</p>
<ol style="list-style-type: decimal">
<li>The need for automatically-generated code probably means that the underlying language lacks the right abstractions (or that you do not understand them).</li>
<li>Either you incur the complexity of implementing the code generation in that same (lacking or ill-understood) language, or you incur the mental overhead of having to coordinate with another language at the same time - possibly a third language, if you handle specifications in a separate language.</li>
<li>You don’t fix a problem in automatically-generated code - you fix the code generator or the specifications, which is nearly always more difficult and has more consequences.</li>
<li>The code generator’s scope tends to expand anywhere generated code touches manually-written code.</li>
</ol>
<p>Of course, avoiding code generation completely is senseless. Compilers are code generators. They run on CPUs probably created (gate-wise) by some form of code generator. The problem is not code generation, but code generation as ad-hoc automation that buries complexity underneath a layer of fresh complexity.</p>
<p>Luckily, plenty of people (besides compiler writers) seem to get code generation right. After my failure to make any progress with cocoOS, I had started reading about <a href="https://github.com/tomahawkins/atom">Atom</a>, an EDSL in Haskell which generates C code for hard realtime embedded software. It looked very promising and solid, but too narrow in scope for what I needed. Shortly after, I found <a href="https://github.com/leepike/Copilot">Copilot</a>, another Haskell EDSL for some similar purposes which generates C either via Atom or <a href="https://hackage.haskell.org/package/sbv">SBV</a> (also a Haskell EDSL). <a href="http://ntrs.nasa.gov/archive/nasa/casi.ntrs.nasa.gov/20120014570.pdf">Experience Report: a Do-It-Yourself High-Assurance Compiler</a> from NASA focuses on Copilot, but identifies some general benefits from the paradigm; it is a short, informative read that I highly recommend.</p>
<p>I stumbled into <a href="http://ivorylang.org/">Ivory</a> from Galois Inc. (another Haskell EDSL, of course) and knew quickly that I had found something very powerful for my own use-case. Their <a href="https://github.com/GaloisInc/smaccmpilot-experiencereport/blob/master/embedded-experience.pdf?raw=true">experience report</a> is a quick read, but a good summary of Ivory (as well as <a href="http://ivorylang.org/tower-overview.html">Tower</a>, yet another Haskell EDSL). It’s still a rather young project, and documentation and examples are sparse. However, it is under active development, and its developers (particularly Lee Pike, who I’ve bothered with plenty of emails) have been very responsive to my inquiries.</p>
<p>(To be clear, these all are Haskell EDSLs oriented to code generation. All of them in some fashion allow the programmer to express a specification within Haskell, and then generate C code at runtime. Haskell code is not actually being built for any embedded target - although, some authors here had interest in doing this via <a href="http://repetae.net/computer/jhc/">JHC</a>, and the <a href="http://www.idris-lang.org/">Idris</a> language extracts the entire runtime and program to C with some recent work going into making this light enough for embedded targets. A certain <a href="http://gauss.ececs.uc.edu/franco_files/franco.html">Dr. Franco</a> at my university insisted to me several years ago that code generation from a specification was the way of the future, and was most pleased when I suggested this year that perhaps he was correct.)</p>
<p>After some more reading and examination here, I started migrating the code over to a combination of Atom and Ivory. Atom quickly proved useful for managing a lot of the concurrency that was present, and generally handling high-level scheduling. The transition from C code to Ivory was rough in spots, but Ivory proved very useful too for representing all kinds of general functionality.</p>
<p>Haskell’s power as a language has been proving immensely useful here. Effectively, the EDSLs have moved the level of meaningful abstraction up into code-generation, and this has both given me much better abstraction and let me eliminate some runtime overhead.</p>
<p>More in-depth examples and explanations on things like Atom, Copilot, Ivory, and SBV will follow on this blog.</p>
<h1 id="references">References</h1>
<h2 id="papers">Papers</h2>
<ol style="list-style-type: decimal">
<li>Armstrong, J. Making reliable distributed systems in the presence of software errors. <a href="http://www.erlang.org/download/armstrong_thesis_2003.pdf" class="uri">http://www.erlang.org/download/armstrong_thesis_2003.pdf</a></li>
<li>Pike, L., Wegmann, N., Niller, S., &amp; Goodloe, A. (2012). Experience Report: a Do-It-Yourself High-Assurance Compiler. <a href="http://ntrs.nasa.gov/archive/nasa/casi.ntrs.nasa.gov/20120014570.pdf" class="uri">http://ntrs.nasa.gov/archive/nasa/casi.ntrs.nasa.gov/20120014570.pdf</a></li>
<li>Hickey, P. C., Pike, L., Elliott, T., Bielman, J., &amp; Launchbury, J. (2014) Building Embedded Systems with Embedded DSLs (Experience Report). <em>ACM 978-1-4503-2873-9/14/09.</em> <a href="https://github.com/GaloisInc/smaccmpilot-experiencereport/blob/master/embedded-experience.pdf?raw=true" class="uri">https://github.com/GaloisInc/smaccmpilot-experiencereport/blob/master/embedded-experience.pdf?raw=true</a></li>
</ol>
<h2 id="websites">Websites</h2>
<ol style="list-style-type: decimal">
<li>cocoOS <a href="http://www.cocoos.net/intro.html" class="uri">http://www.cocoos.net/intro.html</a></li>
<li>Cog: Python Success Stories <a href="https://www.python.org/about/success/cog/" class="uri">https://www.python.org/about/success/cog/</a></li>
<li>atom: A DSL for embedded hard realtime applications. <a href="http://hackage.haskell.org/package/atom" class="uri">http://hackage.haskell.org/package/atom</a> and <a href="https://github.com/tomahawkins/atom" class="uri">https://github.com/tomahawkins/atom</a></li>
<li>sbv: SMT Based Verification: Symbolic Haskell theorem prover using SMT solving. <a href="https://hackage.haskell.org/package/sbv" class="uri">https://hackage.haskell.org/package/sbv</a> and <a href="https://leventerkok.github.io/sbv/" class="uri">https://leventerkok.github.io/sbv/</a></li>
<li>copilot: A stream DSL for writing embedded C programs. <a href="http://hackage.haskell.org/package/copilot" class="uri">http://hackage.haskell.org/package/copilot</a> and <a href="https://leepike.github.io/Copilot/" class="uri">https://leepike.github.io/Copilot/</a></li>
<li>Ivory, an eDSL for safe systems programming. <a href="http://ivorylang.org/" class="uri">http://ivorylang.org/</a> and <a href="https://github.com/GaloisInc/ivory" class="uri">https://github.com/GaloisInc/ivory</a></li>
<li>Jhc Haskell Compiler. <a href="http://repetae.net/computer/jhc/" class="uri">http://repetae.net/computer/jhc/</a></li>
</ol>
]]></summary>
</entry>
<entry>
    <title>Haskelly Beginnings</title>
    <link href="http://haskellembedded.github.io//posts/2015-01-31-haskelly-beginnings.html" />
    <id>http://haskellembedded.github.io//posts/2015-01-31-haskelly-beginnings.html</id>
    <published>2015-01-31T00:00:00Z</published>
    <updated>2015-01-31T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on January 31, 2015
    
        by Calvin Beck
    
</div>
<div class="info">
    
    Tags: 
    
</div>

<p>Greetings, all!</p>
<p>This is the start of a project to expand Haskell’s reach in the embedded world. At the moment we are simply exploring some of the available options, and we hope to expand on the documentation, and examples that are available. Here’s a list of some of the things which we are aware of? Got anymore? Let us know!</p>
<ul>
<li><a href="http://leepike.github.io/Copilot/">Copilot</a></li>
<li><a href="https://hackage.haskell.org/package/atom">Atom</a></li>
<li><a href="http://ivorylang.org/ivory-introduction.html">Ivory</a></li>
</ul>
<p>We’ll have a better idea of what’s going on with this soon. Right now this is essentially just a test of our super cool <a href="http://jaspervdj.be/hakyll/">Hakyll</a> blog using <a href="https://pages.github.com/">GitHub Pages</a></p>
<p>You can find the source for this blog <a href="https://github.com/HaskellEmbedded/HaskellEmbedded.github.io/tree/source">here</a>!</p>
]]></summary>
</entry>

</feed>
